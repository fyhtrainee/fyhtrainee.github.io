{
    "version": "https://jsonfeed.org/version/1",
    "title": "yuHeng's blog",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/09/01/redis-BigKey%E9%97%AE%E9%A2%98/",
            "url": "http://example.com/2023/09/01/redis-BigKey%E9%97%AE%E9%A2%98/",
            "title": "redis BigKey问题",
            "date_published": "2023-09-01T08:14:02.000Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "http://example.com/2023/09/01/redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B/",
            "url": "http://example.com/2023/09/01/redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B/",
            "title": "redis是单线程还是多线程",
            "date_published": "2023-09-01T08:12:51.000Z",
            "content_html": "<h1 id=\"redis是单线程还是多线程的\"><a class=\"markdownIt-Anchor\" href=\"#redis是单线程还是多线程的\">#</a> Redis 是单线程还是多线程的？</h1>\n<h2 id=\"1官网解释\"><a class=\"markdownIt-Anchor\" href=\"#1官网解释\">#</a> 1. 官网解释</h2>\n<h3 id=\"how-can-redis-use-multiple-cpus-or-cores\"><a class=\"markdownIt-Anchor\" href=\"#how-can-redis-use-multiple-cpus-or-cores\">#</a> How can Redis use multiple CPUs or cores?</h3>\n<p>It’s not very frequent that CPU becomes your bottleneck with Redis, as usually Redis is either memory or network bound. For instance, when using pipelining a Redis instance running on an average Linux system can deliver 1 million requests per second, so if your application mainly uses O(N) or O(log(N)) commands, it is hardly going to use too much CPU.</p>\n<p>However, to maximize CPU usage you can start multiple instances of Redis in the same box and treat them as different servers. At some point a single box may not be enough anyway, so if you want to use multiple CPUs you can start thinking of some way to shard earlier.</p>\n<p>You can find more information about using multiple Redis instances in the <span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWRpcy5pby90b3BpY3MvcGFydGl0aW9uaW5n\">Partitioning page</span>.</p>\n<p>As of version 4.0, Redis has started implementing threaded actions. For now this is limited to deleting objects in the background and blocking commands implemented via Redis modules. For subsequent releases, the plan is to make Redis more and more threaded.</p>\n<blockquote>\n<p>CPU 成为 Redis 瓶颈的情况并不常见，因为 Redis 通常都是内存或网络绑定的。例如，当使用流水线时，在普通 Linux 系统上运行的 Redis 实例每秒可提供 100 万个请求，所以如果你的应用程序主要使用 O (N) 或 O (log (N)) 命令，几乎不会占用太多 CPU。</p>\n<p>不过，为了最大限度地提高 CPU 使用率，你可以在同一个盒子中启动多个 Redis 实例，并将它们视为不同的服务器。在某些情况下，一个盒子可能不够用，所以如果你想使用多个 CPU，可以考虑提前分片。</p>\n<p>有关使用多个 Redis 实例的更多信息，请参阅分区页面。</p>\n<p>从 4.0 版开始，Redis 开始实现线程操作。目前，这仅限于在后台删除对象和通过 Redis 模块执行阻塞命令。在后续版本中，我们计划让 Redis 的线程化程度越来越高。</p>\n</blockquote>\n<h2 id=\"2-redis40之前\"><a class=\"markdownIt-Anchor\" href=\"#2-redis40之前\">#</a> 2. Redis4.0 之前</h2>\n<p>在 redis4.x 时代，redis 的任何操作都是单线程的，而单线程的 redis 具有以下几个优点。</p>\n<ol>\n<li>单线程模型使得 redis 的开发和维护更加简单。</li>\n<li>即使使用的是单线程模型，也可以并发地处理多客户端的请求，主要使用的是 IO 多路复用和非阻塞 IO 实现。</li>\n<li>对于 Redis 系统来说，<em><strong>主要的性能瓶颈是内存或者网络带宽而非 CPU</strong></em>。</li>\n</ol>\n<p>单线程引发的问题：</p>\n<ol>\n<li>正常情况下，del 命令可以很快地删除数据，但是当被删除的数据是一个非常大的对象时，例如包含了成千上万个元素的 hash 集合，那么 del 指令就会造成 Redis 主线程卡顿。</li>\n</ol>\n<p>解决方案：惰性删除（lazy del）</p>\n<ol>\n<li>使用 unlink 命令可以实现数据的异步删除的功能，然是处理其读写请求的仍然只有一个线程，所以仍然算是狭义上的单线程。</li>\n</ol>\n<h2 id=\"3-redis67\"><a class=\"markdownIt-Anchor\" href=\"#3-redis67\">#</a> 3. Redis6/7</h2>\n<p>从 redis6/7 开始，redis 正式引入多线程特性和 IO 多路复用。</p>\n<p>官网中所说，<em><strong>redis 的性能瓶颈几乎不会是 cpu 的性能，而是内存或者网络带宽</strong></em>，所以为了提高吞吐量，采用多个 IO 线程来处理网络请求，提高网络请求处理的并行度，Redis6/7 就是采用的这种方法。</p>\n<h4 id=\"主线程和io线程是怎么协作完成请求处理的\"><a class=\"markdownIt-Anchor\" href=\"#主线程和io线程是怎么协作完成请求处理的\">#</a> 主线程和 IO 线程是怎么协作完成请求处理的？</h4>\n<p>I/O 的读和写本身是堵塞的，比如当 socket 中有数据时，Redis 会通过调用先将数据从内核态空间拷贝到用户态空间，再交给 Redis 调用，而这个拷贝的过程就是阻塞的，当数据量越大时拷贝所需要的时间就越多，而这些操作都是基于单线程完成的。</p>\n<div align=center><img data-src=\"https://img1.imgtp.com/2023/08/29/kuJvq97N.png\"></div>\n<p>从 Redis6 开始，就新增了多线程的功能来提高 I/O 的读写性能，他的主要实现思路是将主线程的 IO 读写任务拆分给一组独立的线程去执行，这样就可以使多个 socket 的读写可以并行化了，采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），将最耗时的 Socket 的读取、请求解析、写入单独外包出去，剩下的命令执行仍然由主线程串行执行并和内存的数据交互。</p>\n<p><img data-src=\"https://img1.imgtp.com/2023/08/29/Bky7gENR.png\" alt=\"Redis6/7之前\"></p>\n<h4 id=\"多线程模式是否是默认开启的呢\"><a class=\"markdownIt-Anchor\" href=\"#多线程模式是否是默认开启的呢\">#</a> 多线程模式是否是默认开启的呢？</h4>\n<p>Redis6/7 并不默认开启多线程模式，需要手动开启。</p>\n<p><img data-src=\"https://img1.imgtp.com/2023/08/29/UFnehp5j.png\" alt=\"配置文件截图\"></p>\n<p>Redis 自身出道就是优秀，基于内存操作、数据结构简单、多路复用和非阻塞 I/O、避免了不必要的线程上下文切换等特性，在单线程的环境下依然很快；</p>\n<p>但对于大数据的 key 删除还是卡顿厉害，因此在 Redis 4.0 引入了多线程 unlink key/flushall async 等命令，主要用于 Redis 数据的异步删除；</p>\n<p>无论它如何变化，命令的执行依旧是由主线程串行执行的，因此，即使在多线程下操作 Redis 也不会出现线程安全问题。</p>\n",
            "tags": []
        }
    ]
}