{
    "version": "https://jsonfeed.org/version/1",
    "title": "yuHeng's blog • All posts by \"redis\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/09/01/redis-BigKey%E9%97%AE%E9%A2%98/",
            "url": "http://example.com/2023/09/01/redis-BigKey%E9%97%AE%E9%A2%98/",
            "title": "redis BigKey问题",
            "date_published": "2023-09-01T08:14:02.000Z",
            "content_html": "<h1 id=\"redis-bigkey和相关阻塞式问题\"><a class=\"markdownIt-Anchor\" href=\"#redis-bigkey和相关阻塞式问题\">#</a> Redis BigKey 和相关阻塞式问题</h1>\n<h2 id=\"1-多大算bigkey\"><a class=\"markdownIt-Anchor\" href=\"#1-多大算bigkey\">#</a> 1. 多大算 BigKey</h2>\n<p>根据《阿里云 Redis 开发规范》，string 类型控制在 10kb 以内，hash list set zset 元素个数不要超过 500.</p>\n<p><img data-src=\"https://img1.imgtp.com/2023/08/30/6RGpzh5o.png\" alt=\"阿里云Redis开发规范原文\"></p>\n<h2 id=\"2-bigkey的危害\"><a class=\"markdownIt-Anchor\" href=\"#2-bigkey的危害\">#</a> 2. BigKey 的危害</h2>\n<ol>\n<li>内存不均，集群迁移困难。</li>\n<li>超时删除，BigKey。</li>\n<li>网络流量阻塞。</li>\n</ol>\n<h2 id=\"3-如何发现bigkey\"><a class=\"markdownIt-Anchor\" href=\"#3-如何发现bigkey\">#</a> 3. 如何发现 BigKey</h2>\n<h3 id=\"1-redis-cli-bigkeys\"><a class=\"markdownIt-Anchor\" href=\"#1-redis-cli-bigkeys\">#</a> 1. redis-cli --bigkeys</h3>\n<blockquote>\n<p>给出每种数据结构 Top 1 bigkey，同时给出每种数据类型的键值个数 + 平均大小.</p>\n</blockquote>\n<p>redis-cli -h 127.0.0.1 -p 6379 -a 111111 --bigkeys</p>\n<p>每隔 100 条 scan 指令就会休眠 0.1s，ops 就不会剧烈抬升，但是扫描的时间会变长</p>\n<p>redis-cli -h 127.0.0.1 -p 7001 –-bigkeys -i 0.1</p>\n<p><img data-src=\"https://img1.imgtp.com/2023/08/30/h5v8GyyR.png\" alt=\"执行结果\"></p>\n<h3 id=\"2-memory-usage\"><a class=\"markdownIt-Anchor\" href=\"#2-memory-usage\">#</a> 2. MEMORY USAGE</h3>\n<p><img data-src=\"https://img1.imgtp.com/2023/08/30/NbhtRtUO.png\" alt=\"官网截图\"></p>\n<h2 id=\"4-如何在生产中避免危险命令\"><a class=\"markdownIt-Anchor\" href=\"#4-如何在生产中避免危险命令\">#</a> 4. 如何在生产中避免危险命令</h2>\n<p>通过设置禁用一些命令。以下是 redis.conf 文件的描述。</p>\n<p><img data-src=\"https://img1.imgtp.com/2023/08/30/ZhNhsIte.png\" alt=\"conf文件描述\"></p>\n<p>修改之后，运行结果。</p>\n<p><img data-src=\"https://img1.imgtp.com/2023/08/30/geXIxawS.png\" alt=\"运行结果\"></p>\n<h2 id=\"5-bigkey生产调优\"><a class=\"markdownIt-Anchor\" href=\"#5-bigkey生产调优\">#</a> 5. BigKey 生产调优</h2>\n<h3 id=\"lazy-freeing\"><a class=\"markdownIt-Anchor\" href=\"#lazy-freeing\">#</a> LAZY FREEING</h3>\n<p><a href=\"https://img1.imgtp.com/2023/08/30/qwxyATWq.png\"><img data-src=\"https://img1.imgtp.com/2023/08/30/qwxyATWq.png\" alt=\"1693374956725.png\"></a></p>\n<p><img data-src=\"https://img1.imgtp.com/2023/08/30/uNplzpmq.png\" alt=\"Redis.conf配置截图\"></p>\n<h3 id=\"优化配置\"><a class=\"markdownIt-Anchor\" href=\"#优化配置\">#</a> 优化配置</h3>\n<p><a href=\"https://img1.imgtp.com/2023/08/30/4Zj794Ky.png\"><img data-src=\"https://img1.imgtp.com/2023/08/30/4Zj794Ky.png\" alt=\"1693375221380.png\"></a></p>\n<h2 id=\"6如何删除bigkey\"><a class=\"markdownIt-Anchor\" href=\"#6如何删除bigkey\">#</a> 6. 如何删除 BigKey</h2>\n<p>参照《阿里云 Redis 开发规范》</p>\n<p><a href=\"https://img1.imgtp.com/2023/08/30/DthLgMhj.png\"><img data-src=\"https://img1.imgtp.com/2023/08/30/DthLgMhj.png\" alt=\"1693375353677.png\"></a></p>\n<ol>\n<li>\n<p>String 一般使用 del，过于庞大使用 unlink</p>\n</li>\n<li>\n<p>hash 使用 hscan 每次获取少量 filed-value，再使用 hdel 删除每个 filed</p>\n<p><a href=\"https://img1.imgtp.com/2023/08/30/nxBbSIFY.png\"><img data-src=\"https://img1.imgtp.com/2023/08/30/nxBbSIFY.png\" alt=\"1693375670429.png\"></a></p>\n</li>\n<li>\n<p>list 使用 ltrim 渐进式逐步删除，直至全部删除完毕。</p>\n</li>\n</ol>\n<p><img data-src=\"C:%5CUsers%5CLaptop%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230830141026390.png\" alt=\"image-20230830141026390\"></p>\n<ol start=\"4\">\n<li>set 使用 sscan 每次获取部分元素，再使用 srem 命令删除每个元素。</li>\n</ol>\n<p><img data-src=\"C:%5CUsers%5CLaptop%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230830141121717.png\" alt=\"image-20230830141121717\"></p>\n<ol start=\"5\">\n<li>zset 每次获取部分元素，再使用 ZREMRANGEBYRANK 命令删除每个元素</li>\n</ol>\n<p><a href=\"https://img1.imgtp.com/2023/08/30/aJ4Ix8Qn.png\"><img data-src=\"https://img1.imgtp.com/2023/08/30/aJ4Ix8Qn.png\" alt=\"1693375972000.png\"></a></p>\n<h2 id=\"7-del-vs-unlink\"><a class=\"markdownIt-Anchor\" href=\"#7-del-vs-unlink\">#</a> 7. del vs unlink</h2>\n<p>看到 stackoverflow 上一篇很好的回答贴上来</p>\n<p>Before discussing which one is better, let’s take a look at the difference between these commands. Both  <code>DEL</code>  and  <code>UNLINK</code>  free the key part in blocking mode. And the difference is the way they free the value part.</p>\n<p><code>DEL</code>  always frees the value part in blocking mode. However, if the value is too large, e.g. too many allocations for a large  <code>LIST</code>  or  <code>HASH</code> , it blocks Redis for a long time. In order to solve the problem, Redis implements the  <code>UNLINK</code>  command, i.e. an ‘non-blocking’ delete.</p>\n<p>In fact,  <code>UNLINK</code>  is <strong>NOT always non-blocking/async</strong>. If the value is small, e.g. the size of  <code>LIST</code>  or  <code>HASH</code>  is less than  <code>64</code> , the value will be freed immediately. In this way,  <code>UNLINK</code>  is almost the same as  <code>DEL</code> , except that it costs a few more function calls than  <code>DEL</code> . However, if the value is large, Redis puts the value into a list, and the value will be freed by another thread i.e. the non-blocking free. In this way, the main thread has to do some synchronization with the background thread, and that’s also a cost.</p>\n<p>In a conclusion, if the value is small,  <code>DEL</code>  is at least, as good as  <code>UNLINK</code> . If value is very large, e.g.  <code>LIST</code>  with thousands or millions of items,  <code>UNLINK</code>  is much better than  <code>DEL</code> . You can always safely replace  <code>DEL</code>  with  <code>UNLINK</code> . However, if you find the thread synchronization becomes a problem (multi-threading is always a headache), you can rollback to  <code>DEL</code> .</p>\n<p><strong>UPDATE:</strong></p>\n<p>Since Redis 6.0, there’s a new configuration: <em><strong>lazyfree-lazy-user-del</strong></em>. You can set it to be <em>yes</em>, and Redis will run the  <code>DEL</code>  command as if running a  <code>UNLINK</code>  command.</p>\n",
            "tags": [
                "redis"
            ]
        },
        {
            "id": "http://example.com/2023/09/01/redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B/",
            "url": "http://example.com/2023/09/01/redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B/",
            "title": "redis是单线程还是多线程",
            "date_published": "2023-09-01T08:12:51.000Z",
            "content_html": "<h1 id=\"redis是单线程还是多线程的\"><a class=\"markdownIt-Anchor\" href=\"#redis是单线程还是多线程的\">#</a> Redis 是单线程还是多线程的？</h1>\n<h2 id=\"1官网解释\"><a class=\"markdownIt-Anchor\" href=\"#1官网解释\">#</a> 1. 官网解释</h2>\n<h3 id=\"how-can-redis-use-multiple-cpus-or-cores\"><a class=\"markdownIt-Anchor\" href=\"#how-can-redis-use-multiple-cpus-or-cores\">#</a> How can Redis use multiple CPUs or cores?</h3>\n<p>It’s not very frequent that CPU becomes your bottleneck with Redis, as usually Redis is either memory or network bound. For instance, when using pipelining a Redis instance running on an average Linux system can deliver 1 million requests per second, so if your application mainly uses O(N) or O(log(N)) commands, it is hardly going to use too much CPU.</p>\n<p>However, to maximize CPU usage you can start multiple instances of Redis in the same box and treat them as different servers. At some point a single box may not be enough anyway, so if you want to use multiple CPUs you can start thinking of some way to shard earlier.</p>\n<p>You can find more information about using multiple Redis instances in the <span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWRpcy5pby90b3BpY3MvcGFydGl0aW9uaW5n\">Partitioning page</span>.</p>\n<p>As of version 4.0, Redis has started implementing threaded actions. For now this is limited to deleting objects in the background and blocking commands implemented via Redis modules. For subsequent releases, the plan is to make Redis more and more threaded.</p>\n<blockquote>\n<p>CPU 成为 Redis 瓶颈的情况并不常见，因为 Redis 通常都是内存或网络绑定的。例如，当使用流水线时，在普通 Linux 系统上运行的 Redis 实例每秒可提供 100 万个请求，所以如果你的应用程序主要使用 O (N) 或 O (log (N)) 命令，几乎不会占用太多 CPU。</p>\n<p>不过，为了最大限度地提高 CPU 使用率，你可以在同一个盒子中启动多个 Redis 实例，并将它们视为不同的服务器。在某些情况下，一个盒子可能不够用，所以如果你想使用多个 CPU，可以考虑提前分片。</p>\n<p>有关使用多个 Redis 实例的更多信息，请参阅分区页面。</p>\n<p>从 4.0 版开始，Redis 开始实现线程操作。目前，这仅限于在后台删除对象和通过 Redis 模块执行阻塞命令。在后续版本中，我们计划让 Redis 的线程化程度越来越高。</p>\n</blockquote>\n<h2 id=\"2-redis40之前\"><a class=\"markdownIt-Anchor\" href=\"#2-redis40之前\">#</a> 2. Redis4.0 之前</h2>\n<p>在 redis4.x 时代，redis 的任何操作都是单线程的，而单线程的 redis 具有以下几个优点。</p>\n<ol>\n<li>单线程模型使得 redis 的开发和维护更加简单。</li>\n<li>即使使用的是单线程模型，也可以并发地处理多客户端的请求，主要使用的是 IO 多路复用和非阻塞 IO 实现。</li>\n<li>对于 Redis 系统来说，<em><strong>主要的性能瓶颈是内存或者网络带宽而非 CPU</strong></em>。</li>\n</ol>\n<p>单线程引发的问题：</p>\n<ol>\n<li>正常情况下，del 命令可以很快地删除数据，但是当被删除的数据是一个非常大的对象时，例如包含了成千上万个元素的 hash 集合，那么 del 指令就会造成 Redis 主线程卡顿。</li>\n</ol>\n<p>解决方案：惰性删除（lazy del）</p>\n<ol>\n<li>使用 unlink 命令可以实现数据的异步删除的功能，然是处理其读写请求的仍然只有一个线程，所以仍然算是狭义上的单线程。</li>\n</ol>\n<h2 id=\"3-redis67\"><a class=\"markdownIt-Anchor\" href=\"#3-redis67\">#</a> 3. Redis6/7</h2>\n<p>从 redis6/7 开始，redis 正式引入多线程特性和 IO 多路复用。</p>\n<p>官网中所说，<em><strong>redis 的性能瓶颈几乎不会是 cpu 的性能，而是内存或者网络带宽</strong></em>，所以为了提高吞吐量，采用多个 IO 线程来处理网络请求，提高网络请求处理的并行度，Redis6/7 就是采用的这种方法。</p>\n<h4 id=\"主线程和io线程是怎么协作完成请求处理的\"><a class=\"markdownIt-Anchor\" href=\"#主线程和io线程是怎么协作完成请求处理的\">#</a> 主线程和 IO 线程是怎么协作完成请求处理的？</h4>\n<p>I/O 的读和写本身是堵塞的，比如当 socket 中有数据时，Redis 会通过调用先将数据从内核态空间拷贝到用户态空间，再交给 Redis 调用，而这个拷贝的过程就是阻塞的，当数据量越大时拷贝所需要的时间就越多，而这些操作都是基于单线程完成的。</p>\n<div align=center><img data-src=\"https://img1.imgtp.com/2023/08/29/kuJvq97N.png\"></div>\n<p>从 Redis6 开始，就新增了多线程的功能来提高 I/O 的读写性能，他的主要实现思路是将主线程的 IO 读写任务拆分给一组独立的线程去执行，这样就可以使多个 socket 的读写可以并行化了，采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），将最耗时的 Socket 的读取、请求解析、写入单独外包出去，剩下的命令执行仍然由主线程串行执行并和内存的数据交互。</p>\n<p><img data-src=\"https://img1.imgtp.com/2023/08/29/Bky7gENR.png\" alt=\"Redis6/7之前\"></p>\n<h4 id=\"多线程模式是否是默认开启的呢\"><a class=\"markdownIt-Anchor\" href=\"#多线程模式是否是默认开启的呢\">#</a> 多线程模式是否是默认开启的呢？</h4>\n<p>Redis6/7 并不默认开启多线程模式，需要手动开启。</p>\n<p><img data-src=\"https://img1.imgtp.com/2023/08/29/UFnehp5j.png\" alt=\"配置文件截图\"></p>\n<p>Redis 自身出道就是优秀，基于内存操作、数据结构简单、多路复用和非阻塞 I/O、避免了不必要的线程上下文切换等特性，在单线程的环境下依然很快；</p>\n<p>但对于大数据的 key 删除还是卡顿厉害，因此在 Redis 4.0 引入了多线程 unlink key/flushall async 等命令，主要用于 Redis 数据的异步删除；</p>\n<p>无论它如何变化，命令的执行依旧是由主线程串行执行的，因此，即使在多线程下操作 Redis 也不会出现线程安全问题。</p>\n",
            "tags": [
                "redis"
            ]
        }
    ]
}